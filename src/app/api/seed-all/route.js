// src/app/api/seed-all/route.js
import { NextResponse } from 'next/server';
// Use Admin SDK so seeding bypasses client security rules
import { adminDb, FieldValue } from '../../Lib/firebaseAdmin';

// ---------- Generators ----------
const FIRST = ['Ava','Liam','Noah','Emma','Olivia','Sophia','Isabella','Mia','Charlotte','Amelia','Ethan','Mason','Logan','Lucas','Jackson','Aiden','James','Benjamin','Elijah','Jacob','Harper','Evelyn','Abigail','Emily','Elizabeth','Sofia','Avery','Ella','Scarlett','Grace','Muhammad','Fatima','Aisha','Yusuf','Zainab','Omar','Layla','Ali','Sara','Hassan','Hiro','Yuki','Sora','Akira','Mei','Kenji','Rina','Daichi','Hana','Kaito'];
const LAST = ['Johnson','Smith','Williams','Brown','Jones','Garcia','Miller','Davis','Rodriguez','Martinez','Lee','Kim','Chen','Liu','Wang','Singh','Patel','Khan','Nguyen','Tran','Schneider','Müller','Kowalski','Novak','Silva','Costa','Rossi','Bianchi','Santos','Alvarez'];
const GROUP_NAMES = ['Mountain Adventurers','Tech Enthusiasts','Photography Club','Book Lovers','Cooking Masters','Fitness Warriors','Creative Writers','City Explorers','Board Game Nights','Film Buffs'];
const BIOS = ['Explorer of new places and good coffee.','Tech enthusiast and weekend hiker.','Food lover, amateur photographer.','Always up for a board game night.','Fitness fan and plant parent.','Bookworm and museum hopper.','Music addict, concert chaser.','Learning to cook one recipe at a time.','Runner by morning, gamer by night.','Casual cyclist and picnic enjoyer.'];

const rand = (n) => Math.floor(Math.random() * n);
const pick = (arr) => arr[rand(arr.length)];
const avatar = (i) => '';
const cover = (i) => '';

function usernameFrom(display, suffix) {
  return display.toLowerCase().replace(/[^a-z0-9]+/g, '').slice(0, 16) + suffix;
}

function futureDate(days) {
  const d = new Date();
  d.setDate(d.getDate() + days);
  return d; // Firestore SDK will convert Date to Timestamp
}

// ---------- Seeder ----------
export async function POST(request) {
  const body = await request.json().catch(() => ({}));
  const userCount = Math.max(10, Math.min(300, Number(body?.users) || 80));
  const groupCount = Math.max(3, Math.min(30, Number(body?.groups) || 10));
  const postsPerGroup = Math.max(1, Math.min(10, Number(body?.postsPerGroup) || 3));
  const pollsPerGroup = Math.max(0, Math.min(5, Number(body?.pollsPerGroup) || 1));

  try {
    // 1) Users
    const usersCol = adminDb.collection('users');
    const userBatch = adminDb.batch();
    const users = [];
    for (let i = 0; i < userCount; i++) {
      const first = pick(FIRST);
      const last = pick(LAST);
      const displayName = `${first} ${last}`;
      const userRef = usersCol.doc();
      const user = {
        id: userRef.id,
        displayName,
        username: usernameFrom(first + last, String(i)),
        bio: pick(BIOS),
        profilePictureUrl: (i % 2 === 0)
          ? `https://randomuser.me/api/portraits/men/${(i % 99) + 1}.jpg`
          : `https://randomuser.me/api/portraits/women/${(i % 99) + 1}.jpg`,
        stats: {
          memberOfGroupCount: 0,
          activitiesPlannedCount: rand(12),
        },
        createdAt: FieldValue.serverTimestamp(),
      };
      userBatch.set(userRef, user);
      users.push(user);
    }
    await userBatch.commit();

    // 2) Groups (+ memberships, activity metadata)
    const groupsCol = adminDb.collection('groups');
    const groups = [];
    for (let i = 0; i < groupCount; i++) {
      const groupRef = groupsCol.doc();
      // Random members (10-25)
      const memberCount = 10 + rand(16);
      const memberIds = Array.from({ length: memberCount }, () => users[rand(users.length)].id);
      const owner = users[rand(users.length)];
      const groupDoc = {
        groupName: GROUP_NAMES[i % GROUP_NAMES.length] + ` ${i+1}`,
        description: 'Autogenerated group for seeding end-to-end flows.',
        profilePictureUrl: cover(i),
        members: Array.from(new Set(memberIds)),
        isPinned: rand(10) > 7,
        createdAt: FieldValue.serverTimestamp(),
        category: 'General',
        nextActivity: {
          id: `activity-${i+1}`,
          title: 'Upcoming Meetup',
          date: futureDate(2 + rand(10)),
          location: 'City Center',
          type: 'event',
          joined: rand(2) === 0,
        },
        latestActivity: {
          type: 'message',
          author: { name: owner.displayName, avatarUrl: owner.profilePictureUrl },
          content: 'Welcome to the group! This is an autogenerated latest update.',
          timestamp: futureDate(-rand(7)),
        },
      };
      await groupRef.set(groupDoc);
      groups.push({ id: groupRef.id, ...groupDoc });
    }

    // 3) Posts per group
    const postsCol = adminDb.collection('posts');
    const postsBatch = adminDb.batch();
    const authenticity = ['Live Post', 'Later Post'];
    for (const g of groups) {
      for (let p = 0; p < postsPerGroup; p++) {
        const author = users[rand(users.length)];
        const postRef = postsCol.doc();
        postsBatch.set(postRef, {
          activityTitle: `Post ${p+1} in ${g.groupName}`,
          authorId: author.id,
          groupId: g.id,
          authenticityType: authenticity[rand(authenticity.length)],
          media: [],
          description: 'Autogenerated post content to populate the feed.',
          timestamp: FieldValue.serverTimestamp(),
        });
      }
    }
    await postsBatch.commit();

    // 4) Polls per group
  const pollsCol = adminDb.collection('polls');
  const pollsBatch = adminDb.batch();
    for (const g of groups) {
      for (let k = 0; k < pollsPerGroup; k++) {
        const creator = users[rand(users.length)];
      const pollRef = pollsCol.doc();

      // Activity-oriented poll options with images and types
      const activityOptions = [
        {
          id: 'opt1',
          title: 'Bowling Night',
          description: 'Casual lanes at Strike City',
          imageUrl: 'https://images.unsplash.com/photo-1519677100203-a0e668c92439?w=800&auto=format&fit=crop',
          activityType: 'Bowling',
          votes: 0, voters: []
        },
        {
          id: 'opt2',
          title: 'Karaoke Bar',
          description: 'Sing-along at Neon Mic Lounge',
          imageUrl: 'https://images.unsplash.com/photo-1516280440614-37939bbacd81?w=800&auto=format&fit=crop',
          activityType: 'Karaoke',
          votes: 0, voters: []
        },
        {
          id: 'opt3',
          title: 'Sushi Omakase',
          description: 'Chef’s selection at Mizu',
          imageUrl: 'https://images.unsplash.com/photo-1542736667-069246bdbc74?w=800&auto=format&fit=crop',
          activityType: 'Food & Drink',
          votes: 0, voters: []
        }
      ];

      pollsBatch.set(pollRef, {
        title: `Group Poll ${k+1}`,
        description: 'Autogenerated poll for testing.',
        options: activityOptions,
        groupId: g.id,
        groupName: g.groupName,
        createdBy: creator.id,
        createdByName: creator.displayName,
        createdAt: FieldValue.serverTimestamp(),
        expiresAt: null,
        isActive: true,
        type: 'seed_poll',
        totalVotes: 0,
      });
      }
    }
    await pollsBatch.commit();

    // 5) Direct chats and messages (lightweight)
    const chatsCol = adminDb.collection('chats');
    for (let c = 0; c < 8; c++) {
      const u1 = users[rand(users.length)].id;
      let u2 = users[rand(users.length)].id;
      if (u1 === u2) u2 = users[rand(users.length)].id;
      const chatDoc = await chatsCol.add({ members: [u1, u2] });
      const msgs = chatsCol.doc(chatDoc.id).collection('messages');
      await msgs.add({ senderId: u1, text: 'Hey there! Seeded message.', timestamp: FieldValue.serverTimestamp() });
      await msgs.add({ senderId: u2, text: 'All good! Testing chat.', timestamp: FieldValue.serverTimestamp() });
    }

    // 6) Group messages
    for (const g of groups.slice(0, Math.min(groups.length, 12))) {
      const gm = groupsCol.doc(g.id).collection('messages');
      const a = users[rand(users.length)].id;
      const b = users[rand(users.length)].id;
      await gm.add({ senderId: a, text: 'Welcome everyone!', timestamp: FieldValue.serverTimestamp() });
      await gm.add({ senderId: b, text: 'Happy to be here 🎉', timestamp: FieldValue.serverTimestamp() });
    }

    return NextResponse.json({
      success: true,
      summary: {
        users: userCount,
        groups: groupCount,
        posts: groupCount * postsPerGroup,
        polls: groupCount * pollsPerGroup,
        chats: 8,
      },
      note: 'All seed data written to Firestore.',
    });
  } catch (error) {
    console.error('❌ Seed-all failed:', error);
    return NextResponse.json({ success: false, error: error.message }, { status: 500 });
  }
}

// Convenience GET: creates defaults
export async function GET() {
  const req = new Request('http://local/seed-all', {
    method: 'POST',
    body: JSON.stringify({}),
  });
  return POST(req);
}

