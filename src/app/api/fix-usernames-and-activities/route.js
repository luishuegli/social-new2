import { NextResponse } from 'next/server';
import { adminDb } from '../../Lib/firebaseAdmin';

function slugify(name) {
  return String(name || 'group')
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '')
    .slice(0, 18);
}

export async function POST() {
  try {
    const groupsSnap = await adminDb.collection('groups').get();
    const usernames = new Set();
    const updates = [];
    let createdActivities = 0;

    for (const doc of groupsSnap.docs) {
      const data = doc.data() || {};
      // Backfill username if missing
      if (!data.username) {
        let base = slugify(data.groupName || data.name || doc.id);
        let candidate = base;
        let counter = 1;
        while (usernames.has(candidate)) {
          candidate = `${base}${counter++}`;
        }
        usernames.add(candidate);
        updates.push(doc.ref.update({ username: candidate }));
      } else {
        usernames.add(String(data.username));
      }

      // Ensure activities doc exists for nextActivity
      const next = data.nextActivity;
      if (next && next.id) {
        const actRef = adminDb.collection('activities').doc(next.id);
        const actDoc = await actRef.get();
        if (!actDoc.exists) {
          await actRef.set({
            id: next.id,
            title: next.title || 'Group Activity',
            description: `Autogenerated activity for ${data.groupName || data.name || 'Group'}`,
            groupId: doc.id,
            groupName: data.groupName || data.name || 'Group',
            date: next.date || new Date(),
            location: next.location || '',
            participants: Array.isArray(next.participants) ? next.participants : [],
            status: 'planned',
            creatorId: data.createdBy || 'system',
            createdAt: new Date(),
            updatedAt: new Date(),
            type: 'group_activity',
          });
          createdActivities++;
        }
      }
    }

    if (updates.length > 0) {
      await Promise.all(updates);
    }

    return NextResponse.json({ ok: true, updatedUsernames: updates.length, createdActivities });
  } catch (e) {
    return NextResponse.json({ ok: false, error: e.message }, { status: 500 });
  }
}


